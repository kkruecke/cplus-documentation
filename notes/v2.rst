As Nikolia Josuitis noted in `C++17 The Complete Reference <http://www.cppstd17.com/>`_ , on page ??, Value Categories don't apply to values but rather to expressions.

Here is a `history of value categories <https://en.cppreference.com/w/cpp/language/value_category#History>`_ from the C programming language to C++17 [take from cppreference and BS].

C 
^^

C expressions were categorized as "lvalue expressions" or all others (functions and non-object values), where "lvalue" meant an expression that identifies an object, a "locator value". 

C++98
^^^^^

Pre-2011 C++ followed the C model, but assigned the name "rvalue" to non-lvalue expressions, made functions into lvalues, and added the rule that references can bind to lvalues, but only references to const can bind to
rvalues. Several non-lvalue C expressions became lvalue expressions in C++. 

C++11
^^^^^

Move semantics introduced in C++11 required further revision. (BS start-->) The "two properties that matter for for an object when it comes to addressing, copying and moving" are:

    * *Has Identity*: The program has the name of, address of, or reference to the object so that it is possible to determine if two objects are the same, whether the value has changed, etc.
    * *Movable*: the object may be moved from (i.e. we are allowed to move its value to another location and leave the object in a valid but unspecified state, rather than copying it).

    It turns out that three of the four possibilities of these two properites are needed to precisely describe the C++ language rules (we have no need for object that do not have identity and cannot be moved). Using "**m**
    for movable" and "**i** for has identity", we can represent this classification of expressions graphically:
    for movable" and "**i** for has identity", we can represent this classification of expressions graphically:

.. todo:: Is this image really the best. I think the Venn Diagram is better or better yet the box diagram from the article "...., help" at ../images/value-categories1.png. 

.. figure:: ../images/value-categories.jpg
   :alt: value categories
   :align: center 
   :scale: 100 %
   :figclass: custom-figure

   **Figure: value categories** 

So, a classical lvalue is something that has identity and cannot be moved (because we could examine it after the move), and a classical rvalue is anything that we are allowed to move from. (BS end).

(ccpreference start --->) cppreference explains it this way: Value categories were redefined to identify these two independent properties of expressions:

    **has identity**: it's possible to determine whether the expression refers to the same entity as another expression, such as by comparing addresses of the objects or the functions they identify (obtained directly or indirectly)
    **can be moved from**: move constructor, move assignment operator, or another function overload that implements move semantics can bind to the expression. 

This lead to the following value categories for expressions:

    **have identity** and **cannot be moved from** are called lvalue expressions;
    **have identity** and **can be moved from** are called xvalue expressions;
    **do not have identity** and **can be moved from** are called prvalue ("pure rvalue") expressions;
    **do not have identity** and **cannot be moved from** are not used. 

The expressions that have identity are called "glvalue expressions" (glvalue stands for "generalized lvalue"). Both lvalues and xvalues are glvalue expressions.

The expressions that can be moved from are called "rvalue expressions". Both prvalues and xvalues are rvalue expressions. (<----cppreference end)


.. todo:: synthesize any important explanations from the other articles and provide examples that explain each of the value categories. Finally add the conclusion from C++PL that the two practical categories are rvalue and value. Add a final comment about
   C++17 and materialization.
