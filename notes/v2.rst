Value Categories: Revision
==========================

Helpful Articles
----------------

* `CppCon 2019:Ben Saks â€œBack to Basics: Understanding Value Categories <https://www.youtube.com/watch?v=XS2JddPq7GQ>`_
* https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/cpp-value-categories
* `Bjarne Stroustrup Article Introducing Value Categories <http://www.stroustrup.com/terminology.pdf>`_
* `Video: C++ lvalue rvalue xvalue glvalue prvalue <https://www.youtube.com/watch?v=yIOH95oIKbo>`_
* `Stackoverflow Explanation <https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues>`_ 


As Nikolia Josuitis noted in `C++17 The Complete Reference <http://www.cppstd17.com/>`_ , on page ??, Value Categories don't apply to values but rather to expressions.

Value categories [#fhistory]_
------------------------------

C Programming Language 
^^^^^^^^^^^^^^^^^^^^^^

In C expressions were categorized as "lvalue expressions" and others (functions and non-object values), where "lvalue" meant an expression that identifies an object, a "locator value" in memory; 
for example,

.. code-block:: cpp

    int n;
    n = 1;

in the expression ``n = 1``, the subexpression **n** refers to an integer object, a specific location in memory. Thus **n** is an lvalue. The term lvalue derives its name from the fact that only objects can
appear on the left hand side of an assignment and can be assigned to.

lvalue and rvalue relevance in C++98
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Pre-2011 C++ followed the C model, but assigned the name "rvalue" to non-lvalue expressions, made functions into lvalues, and added the rule that references can bind to lvalues, but only
references to const can bind to rvalues. Several non-lvalue C expressions became lvalue expressions in C++. In the expression above ``n = 1;``, **1** is an rvalue because it is not an object, a location in memory, an lvalue.

Distinguishing rvalues from lvalues allows the compiler to improve the efficiency of the code. The compile does not need to place rvalues in storage. When an lvalue is used on the right hand side of an assignment

.. code-block:: cpp

    int n, m;
    n = 1;
    m = n; // m undergoes lvalue to rvalue conversion

it is said to undergo *lvalue-to-rvalue* conversion. When we talk about something being an lvalue, we are concerned with where the object lives, but when we only need to know the value it holds, we can view the object as an rvalue.

lvalues and rvalues are relevant in other contexts than assignment. The binary operator + is an example. It operands can be either rvalues or lvalues. 

.. code-block:: cpp

    x + 2   // lvalue + rvalue
    5 + 2   // rvalue + rvalue
    x + y   // lvalue + lvalue

The result of the + operation is a temporary object that the compiler may place in a register. Since this temporary object is not guaranteed to be in memory, it is therefore an rvalue. Another of example of an lvalue is the 
result of the derefence operator

.. code-block:: cpp

    int a[N];
    int *p = a;
    char *s = nullptr;
    *p = 3;     // *p is an lvalue  
    *s = '\0';  // *s is an lvalue even though s is null and *s causes undefined behavior.

In C++, rvaluse of class type do occupty data storage. Why? Consider 

.. code-block:: cpp

    struct S {int x; int y;};
    S foo();
    int j = foo().y; // foo() is an rvalue that occupies storage.

To get the y member of the struct S returned by foo(), we need the base address (of the struct S returned by foo()), and any object with an address occupies storage.

Recap 

============== =================== =============
Value Category Can Take Address Of Can Assign To
============== =================== ============= 
lvlaue         yes                 yes
const lvlaue   yes                 no
rvalue*        no                  no
============== =================== ============= 

.. note:: rvalues of class type do occupy storage. STOPPED at 30:10.

References

C++11
^^^^^

Introduced in C++11, move semantics required value categories to be redefined. C++11 has three main value categories: lvalue, xvalue (or eXpiring value), and prvalue (pure rvalues). To explain these categories,
we quote from page 166 of **The C++ Programming Language, 4th Edition**:

    There are two properties that matter for for an object when it comes to addressing, copying and moving:
    
    * **Has Identity**: The program has the name of, address of, or reference to the object so that it is possible to determine if two objects are the same, whether the value has changed,
      etc.
    * **Movable**: the object may be moved from (i.e. we are allowed to move its value to another location and leave the object in a valid but unspecified state, rather than copying it).
    
    It turns out that three of the four possibilities of these two properites are needed to precisely describe the C++ language rules (we have no need for object that do not have
    identity and cannot be moved). Using "**m** for movable" and "**i** for has identity", we can represent this classification of expressions graphically:
    
.. figure:: ../images/value-categories-bs.jpg
   :alt: value categories
   :align: center 
   :scale: 100 %
   :figclass: custom-figure

   **Figure: value categories** 

    So, a classical lvalue is something that has identity and cannot be moved (because we could examine it after the move), and a classical rvalue is anything that we are allowed to move
    from. 

.. todo:: Add BS comments on each these terms and an example or two -- all from pa 166. 

..

Another good explanation of C++11 value categories is from `cppreference's article <https://en.cppreference.com/w/cpp/language/value_category>`_, which offers this explanation:
    
    With the introduction of move semantics in C++11, value categories were redefined to characterize two independent properties of expressions:
    
    * **has identity**: it's possible to determine whether the expression refers to the same entity as another expression, such as by comparing addresses of the objects or the functions they identify (obtained directly or indirectly)
    * **can be moved from**: move constructor, move assignment operator, or another function overload that implements move semantics can bind to the expression. 
    
    This lead to the following value categories for expressions:
    
    **have identity** and **cannot be moved from** are called lvalue expressions;
    **have identity** and **can be moved from** are called xvalue expressions;
    **do not have identity** and **can be moved from** are called prvalue ("pure rvalue") expressions;
    **do not have identity** and **cannot be moved from** are not used. 
    
    The expressions that have identity are called "glvalue expressions" (glvalue stands for "generalized lvalue"). Both lvalues and xvalues are glvalue expressions.
    
    The expressions that can be moved from are called "rvalue expressions". Both prvalues and xvalues are rvalue expressions.
    
.. todo:: include a similar diagram as the last one on https://blog.knatten.org/2018/03/09/lvalues-rvalues-glvalues-prvalues-xvalues-help

Examples
--------

.. todo:: Evaluate these articles:

See the examples and explanations `Building Intuition on value categories <http://marcodiiga.github.io/building-intuition-on-value-categories>`_. How worthwile is this article? 
Check out this article   http://bajamircea.github.io/coding/cpp/2016/04/07/move-forward.html. Same question.
These are two very good sites: `The deal with C++14 xvalues <https://blog.jeaye.com/2017/03/19/xvalues/>`_ and `Value Categories cheatsheet <https://github.com/jeaye/value-category-cheatsheet/blob/master/value-category-cheatsheet.pdf>`_ <-- very good.

.. todo:: Mention C++17 materialization changes impact on value categories.

.. todo:: Use BS's example on page 166 and any cppreference or other articles-above examples. Also synthesize any important explanations from the other articles, including Dr. Sheep's video. The keep thing is to provide examples at top. 
   Finally add BS's conclusion from C++PL that the two practical categories are rvalue and value. Add a final comment about C++17 and materialization.

.. rubric:: Footnotes

.. [#fhistory] This material is from `Value Categories <https://en.cppreference.com/w/cpp/language/value_category#history>`_.
